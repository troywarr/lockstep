// Generated by CoffeeScript 1.7.1
(function() {
  var clockTime, elapsedTime, expect, noop, spy, stub;

  expect = chai.expect;

  spy = sinon.spy();

  stub = sinon.stub();

  noop = function() {};

  elapsedTime = {
    milliseconds: 123456789,
    seconds: 123456.789,
    minutes: 2057.61315,
    hours: 34.2935525,
    days: 1.4288980208333333
  };

  clockTime = {
    milliseconds: 789,
    seconds: 36,
    minutes: 17,
    hours: 10,
    days: 1
  };

  describe('Lockstep', function() {
    describe('constructor', function() {
      return it('should initialize with timer not running', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.running).to.equal(false);
      });
    });
    describe('#_checkArguments()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_checkArguments');
      });
      it('should throw if no arguments are supplied', function() {
        return expect(function() {
          return new Lockstep;
        }).to["throw"]('No arguments supplied.');
      });
      it('should throw if the single argument supplied is not a function or object', function() {
        return expect(function() {
          return new Lockstep('foo');
        }).to["throw"]('Bad arguments supplied (wrong type).');
      });
      it('should throw if the single argument supplied is an object not containing a "step" function', function() {
        return expect(function() {
          return new Lockstep({});
        }).to["throw"]('Bad arguments supplied (no valid "step" function).');
      });
      it('should throw if the two arguments supplied are not a function and an object', function() {
        return expect(function() {
          return new Lockstep('foo', 'bar');
        }).to["throw"]('Bad arguments supplied (wrong type).');
      });
      it('should throw if the two arguments supplied both identify a "step" function', function() {
        return expect(function() {
          return new Lockstep({
            step: noop
          }, noop);
        }).to["throw"]('Bad arguments supplied (redundant "step" function).');
      });
      it('should not throw if the single argument supplied is a function', function() {
        return expect(function() {
          return new Lockstep(noop);
        }).to.not["throw"]();
      });
      it('should not throw if the single argument supplied is an object containing a "step" function', function() {
        return expect(function() {
          return new Lockstep({
            step: noop
          });
        }).to.not["throw"]();
      });
      it('should not throw if the two arguments supplied are an object not containing a "step" function and a "step" function', function() {
        return expect(function() {
          return new Lockstep({}, noop);
        }).to.not["throw"]();
      });
      return it('should not throw if two good arguments are supplied, plus a useless additional argument', function() {
        return expect(function() {
          return new Lockstep({}, noop, 'foo');
        }).to.not["throw"]();
      });
    });
    describe('#_buildSettings()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_buildSettings');
      });
      return it('should return an object', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._buildSettings({})).to.be.an('object');
      });
    });
    describe('#_millisecondsToClockTime()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_millisecondsToClockTime');
      });
      it('should return an object', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._millisecondsToClockTime(123456789)).to.be.an('object');
      });
      return it('should return specific properties and values', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._millisecondsToClockTime(123456789)).to.deep.equal(clockTime);
      });
    });
    describe('#_millisecondsToElapsedTime()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_millisecondsToElapsedTime');
      });
      it('should return an object', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._millisecondsToElapsedTime(123456789)).to.be.an('object');
      });
      return it('should return specific properties and values', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._millisecondsToElapsedTime(123456789)).to.deep.equal(elapsedTime);
      });
    });
    describe('#_elapsedTimeToMilliseconds()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_elapsedTimeToMilliseconds');
      });
      it('should return a number', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._elapsedTimeToMilliseconds(elapsedTime)).to.be.a('number');
      });
      return it('should return a specific value', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._elapsedTimeToMilliseconds(elapsedTime)).to.equal(123456789);
      });
    });
    describe('#_clockTimeToMilliseconds()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_clockTimeToMilliseconds');
      });
      it('should return a number', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._clockTimeToMilliseconds(clockTime)).to.be.a('number');
      });
      return it('should return a specific value', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep._clockTimeToMilliseconds(clockTime)).to.equal(123456789);
      });
    });
    describe('#_loop()', function() {
      return it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_loop');
      });
    });
    describe('#_step()', function() {
      return it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_step');
      });
    });
    describe('#_pad()', function() {
      return it('should be callable', function() {
        return expect(Lockstep).to.respondTo('_pad');
      });
    });
    describe('#start()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('start');
      });
      it('should increment start counter', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start();
        return expect(lockstep.count.start).to.equal(1);
      });
      it('should set timer to running', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start();
        return expect(lockstep.running).to.equal(true);
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.start()).to.equal(lockstep);
      });
    });
    describe('#stop()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('stop');
      });
      it('should increment stop counter', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start().stop();
        return expect(lockstep.count.stop).to.equal(1);
      });
      it('should set timer to not running', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start().stop();
        return expect(lockstep.running).to.equal(false);
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.stop()).to.equal(lockstep);
      });
    });
    describe('#reset()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('reset');
      });
      it('should increment reset counter', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start().reset();
        return expect(lockstep.count.reset).to.equal(1);
      });
      it('should still be running if no arguments are passed', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start().reset();
        return expect(lockstep.running).to.equal(true);
      });
      it('should not increment stop counter if no arguments are passed', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        lockstep.start().reset();
        return expect(lockstep.count.stop).to.equal(0);
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.reset()).to.equal(lockstep);
      });
    });
    describe('#add()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('add');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.add()).to.equal(lockstep);
      });
    });
    describe('#subtract()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('subtract');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.subtract()).to.equal(lockstep);
      });
    });
    describe('#getInfo()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('getInfo');
      });
      return it('should return an object', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.getInfo()).to.be.an('object');
      });
    });
    describe('#setElapsedTime()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('setElapsedTime');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.setElapsedTime()).to.equal(lockstep);
      });
    });
    describe('#when()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('when');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.when()).to.equal(lockstep);
      });
    });
    describe('#every()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('every');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.every()).to.equal(lockstep);
      });
    });
    describe('#while()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('while');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep["while"]()).to.equal(lockstep);
      });
    });
    describe('#during()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('during');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.during()).to.equal(lockstep);
      });
    });
    describe('#beginning()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('beginning');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.beginning()).to.equal(lockstep);
      });
    });
    return describe('#ending()', function() {
      it('should be callable', function() {
        return expect(Lockstep).to.respondTo('ending');
      });
      return it('should return the context object for chainability', function() {
        var lockstep;
        lockstep = new Lockstep(noop);
        return expect(lockstep.ending()).to.equal(lockstep);
      });
    });
  });

}).call(this);
